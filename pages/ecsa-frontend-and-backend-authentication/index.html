<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      font-size: 16px;
      line-height: 1.6;
      max-width: 85%;
      margin: 0 auto;
      padding: 2rem;
      color: #333;
    }
    h1, h2, h3, h4, h5, h6 {
      font-weight: 600;
      margin-bottom: 0;
    }
    h1 {
      font-size: 2em;
      margin-top: 2rem;
      background-color: #FBF3DB;
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      display: inline-block;
    }
    h2 {
      font-size: 1.5em;
      margin-top: 1.5rem;
      background-color: #DDEBF1;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      display: inline-block;
    }
    h3 { font-size: 1.25em; margin-top: 1rem; }
    /* Heading block wrappers */
    .heading-block { margin: 0; padding: 0; }
    .heading-block h1, .heading-block h2, .heading-block h3 { margin-top: 0; }
    .h1-block { margin-top: 2rem; }
    .h2-block { margin-top: 1.5rem; }
    .h3-block { margin-top: 1rem; }
    p { margin-bottom: 1em; font-size: 16px; }
    ul, ol {
      margin-bottom: 1em;
      padding-left: 1.5em;
      list-style-position: outside;
    }
    ul { list-style-type: disc; }
    ol { list-style-type: decimal; }
    li {
      margin-bottom: 0.25em;
      display: list-item;
      font-size: 16px;
    }
    ul ul, ol ul { list-style-type: circle; }
    ul ul ul, ol ul ul { list-style-type: square; }
    ol ol { list-style-type: lower-alpha; }
    ol ol ol { list-style-type: lower-roman; }
    code {
      background: #f6f8fa;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 85%;
    }
    pre {
      background: #f6f8fa;
      padding: 1em;
      border-radius: 6px;
      overflow-x: auto;
      margin-bottom: 1em;
    }
    pre code {
      background: none;
      padding: 0;
      font-size: 100%;
    }
    /* Code block with header and line numbers */
    .code-block {
      background: #1e1e1e;
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 1em;
    }
    .code-block .code-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5rem 1rem;
      background: #161616;
      border-bottom: 1px solid #333;
    }
    .code-block .code-lang {
      color: #9ca3af;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .code-block .code-body {
      display: flex;
      padding: 1rem 0;
    }
    .code-block .line-numbers {
      display: flex;
      flex-direction: column;
      padding: 0 1rem 0 1rem;
      text-align: right;
      user-select: none;
      color: #6b7280;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 1rem;
      line-height: 1.625;
    }
    .code-block .line-numbers .line-number {
      display: block;
    }
    .code-block pre {
      flex: 1;
      background: transparent;
      margin: 0;
      padding: 0 1rem 0 0;
      overflow-x: auto;
    }
    .code-block pre code {
      color: #d4d4d4;
      font-size: 1rem;
      line-height: 1.625;
    }
    .terminal-block {
      background: #1e1e1e;
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 1em;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    .terminal-block .terminal-header {
      background: linear-gradient(180deg, #3c3c3c 0%, #2d2d2d 100%);
      padding: 0.5rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      border-bottom: 1px solid #1a1a1a;
    }
    .terminal-block .terminal-dots {
      display: flex;
      gap: 8px;
    }
    .terminal-block .terminal-dots span {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    .terminal-block .terminal-dots span:nth-child(1) { background: #ff5f57; }
    .terminal-block .terminal-dots span:nth-child(2) { background: #febc2e; }
    .terminal-block .terminal-dots span:nth-child(3) { background: #28c840; }
    .terminal-block .terminal-title {
      flex: 1;
      text-align: center;
      color: #9ca3af;
      font-size: 0.8rem;
      font-weight: 500;
      margin-right: 60px;
    }
    .terminal-block pre {
      background: transparent;
      margin: 0;
      padding: 1rem;
      font-family: 'JetBrains Mono', 'SF Mono', 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 16px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .terminal-block pre code {
      background: transparent;
      color: #d1d5db;
      padding: 0;
      font-size: inherit;
      font-family: inherit;
    }
    .terminal-block .terminal-prompt {
      color: #4ade80;
      user-select: none;
    }
    blockquote {
      border-left: 4px solid #ddd;
      margin: 1em 0;
      padding-left: 1em;
      color: #666;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 1em;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 0.75em;
      text-align: left;
    }
    th {
      background: #f6f8fa;
      font-weight: 600;
    }
    a {
      color: #0969da;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    img {
      max-width: 100%;
      height: auto;
    }
    .callout {
      background: #f7f6f3;
      padding: 1em;
      border-radius: 6px;
      display: flex;
      gap: 0.75em;
      margin-bottom: 1em;
    }
    .callout-emoji {
      font-size: 1.25em;
    }
    .alert {
      padding: 1rem;
      border-radius: 6px;
      border-left: 4px solid;
      margin-bottom: 1em;
      display: flex;
      gap: 0.75rem;
    }
    .alert-info {
      background: #dbeafe;
      border-left-color: #3b82f6;
    }
    .alert-warning {
      background: #fef3c7;
      border-left-color: #f59e0b;
    }
    .alert-error {
      background: #fee2e2;
      border-left-color: #ef4444;
    }
    .alert-success {
      background: #d1fae5;
      border-left-color: #10b981;
    }
    .alert-note {
      background: #f3f4f6;
      border-left-color: #6b7280;
    }
    .alert::before {
      content: '';
      font-size: 1.25em;
    }
    .alert-info::before { content: 'üí°'; }
    .alert-warning::before { content: '‚ö†Ô∏è'; }
    .alert-error::before { content: 'üö®'; }
    .alert-success::before { content: '‚úÖ'; }
    .alert-note::before { content: 'üìå'; }
    .checklist-item {
      display: flex;
      align-items: start;
      gap: 0.75rem;
      margin-bottom: 0.5em;
    }
    .checklist-item input[type="checkbox"] {
      margin-top: 0.375rem;
      width: 1rem;
      height: 1rem;
      cursor: not-allowed;
    }
    .checklist-item input[type="checkbox"]:checked + span {
      text-decoration: line-through;
      color: #9ca3af;
    }
    .file-tree {
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 1em;
    }
    .file-tree::before {
      content: attr(data-title);
      display: block;
      background: #f3f4f6;
      color: #6b7280;
      padding: 0.5rem 1rem;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border-bottom: 1px solid #e5e7eb;
    }
    .file-tree pre {
      background: transparent;
      color: #374151;
      margin: 0;
      padding: 1rem;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 14px;
      line-height: 1.6;
    }
    .video-embed {
      position: relative;
      padding-bottom: 56.25%;
      height: 0;
      overflow: hidden;
      margin-bottom: 1em;
      border-radius: 6px;
    }
    .video-embed iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    .file-download {
      background: #f6f8fa;
      border: 1px solid #e1e4e8;
      border-radius: 6px;
      padding: 1em;
      margin-bottom: 1em;
    }
    .file-download a {
      display: inline-flex;
      align-items: center;
      gap: 0.5em;
      color: #0969da;
      font-weight: 500;
    }
    .file-download a::before {
      content: 'üìé';
    }
    .page-link-block {
      display: block;
      width: 100%;
      padding: 0.5rem;
      margin: 0 -0.5rem 1em -0.5rem;
      border-radius: 0.25rem;
      transition: background-color 0.15s;
      cursor: pointer;
    }
    .page-link-block:hover {
      background-color: #f3f4f6;
    }
    .page-link-block a {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: #111827;
      font-weight: 600;
      text-decoration: underline;
    }
    .page-link-block a:hover {
      text-decoration: underline;
    }
    .page-link-block a::before {
      content: 'üìÑ';
      font-size: 1rem;
      flex-shrink: 0;
    }
    .profile-card {
      display: flex;
      flex-direction: column;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 1em;
      background: white;
      width: 100%;
    }
    .columns .profile-card {
      max-width: 100%;
    }
    .profile-card img {
      width: 100%;
      aspect-ratio: 4 / 3;
      object-fit: cover;
      background: #f3f4f6;
      margin: 0;
    }
    .profile-card > div {
      padding: 1rem;
    }
    .profile-card strong {
      display: block;
      font-size: 16px;
      font-weight: 600;
      color: #111827;
    }
    .profile-card em {
      display: block;
      font-size: 14px;
      font-style: normal;
      color: #6b7280;
      margin-top: 0.25rem;
    }
    .embed-container {
      position: relative;
      padding-bottom: 56.25%;
      height: 0;
      overflow: hidden;
      margin-bottom: 1em;
      border-radius: 6px;
      border: 1px solid #e1e4e8;
    }
    .embed-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    .columns {
      display: grid;
      gap: 1.5rem;
      margin-bottom: 1em;
    }
    .columns[data-columns="2"] {
      grid-template-columns: repeat(2, 1fr);
    }
    .columns[data-columns="3"] {
      grid-template-columns: repeat(3, 1fr);
    }
    .columns[data-columns="4"] {
      grid-template-columns: repeat(4, 1fr);
    }
    .column {
      min-height: 50px;
    }
    @media (max-width: 768px) {
      .columns {
        grid-template-columns: 1fr !important;
      }
    }
  </style>
</head>
<body>
<div class="heading-block h1-block"><h1>Authentication</h1></div>
<p>For this assignment we are going to build an <a href="https://expressjs.com/">express</a> and <a href="https://www.mongodb.com/">mongodb</a> CRUD api server for our react+zustand blog frontend. This will finally bring our stack all the way down to the database. In this part we‚Äôre going to be adding in&nbsp;</p>
<div class="video-embed"><iframe src="https://res.cloudinary.com/dali-lab/video/upload/c_scale,w_800/v1589346003/cs52/withauth-small.webm" frameborder="0" allowfullscreen></iframe></div>
<div class="heading-block h2-block"><h2>Assignment At a Glance</h2></div>
<ul><li>Authentication: We‚Äôll extend both our frontend and our backend to support authentication and users!</li></ul>
<p>On the frontend we‚Äôll want to add a place for users to sign in. We‚Äôll create a <code>/signin</code>, <code>/signup</code>, and <code>/signout</code> routes and add a way to restrict access to certain routes based on authentication. We‚Äôll do this by designing our own higher order component.</p>
<p>On the api server, we‚Äôre going to also add <code>/signin</code> and <code>/signup</code> routes that will connect to a new User model and Controller. We will also use <a href="http://passportjs.org/">Passport.js</a> to make JWT‚Äôs for us.</p>
<div class="heading-block h2-block"><h2>Some Setup</h2></div>
<p>We‚Äôll just continue working on the same code from Lab5.</p>
<p>We‚Äôre going to do a new thing with our git repos. We‚Äôre going to <code>tag</code> a certain revision so you‚Äôll know where you started on authentication.</p>
<p>üöÄ Go into your Lab5 directory and run:</p>
<div class="terminal-block"><div class="terminal-header"><div class="terminal-dots"><span></span><span></span><span></span></div><span class="terminal-title">Terminal</span></div><pre><code class="language-bash">git checkout -b withAuth</code></pre></div>
<p>üöÄ Go into your Lab4 directory and run:</p>
<div class="terminal-block"><div class="terminal-header"><div class="terminal-dots"><span></span><span></span><span></span></div><span class="terminal-title">Terminal</span></div><pre><code class="language-bash">git checkout -b withAuth</code></pre></div>
<p>Great, now you have a feature branch where you are adding in authentication, and a main branch before you veered off course and made this terrible decision to add authentication to your lovely content platform.</p>
<p>You will end up with 3 server urls at the end of this:  A hosted url for loading the frontend, a hosted url for the api server, and an Atlas Cloud Mongo database url. In your hosting platform (render.com) for each of lab4 and lab5 you can create a new service to publish your withAuth branches as separate services (don‚Äôt use the same service as your prior labs).</p>
<p>We‚Äôll be working on both the api server and frontend app. So you‚Äôll have two code windows open and two services running - both frontend and backend!</p>
<div class="heading-block h1-block"><h1>Auth Enabled API</h1></div>
<p>We shall start with the backend.</p>
<div class="heading-block h2-block"><h2>Secret Key</h2></div>
<p>For signing our JWT‚Äôs on the <strong>server side</strong> we‚Äôll need a secret key. Might as well set that up now.</p>
<p>We‚Äôll need to create an <code>AUTH_SECRET</code> environment variable with some long random string (any characters).</p>
<p>Use the <a href="https://www.npmjs.com/package/dotenv"><code>dotenv</code></a> module to import it into your code. IE. Save <code>AUTH_SECRET="somerandomstringthiscanbeanythingyoushouldmakeityourown"</code> into a <code>.env</code> file that you do not add to git.</p>
<p>üöÄ Add <code>.env</code> to your <code>.gitignore</code> file.</p>
<p>Then in your code in any file where you need the secret you can use:</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span></div><pre><code class="language-javascript">import dotenv from 'dotenv';
dotenv.config({ silent: true });

// and then the secret is usable this way:
process.env.AUTH_SECRET;</code></pre></div></div>
<p>‚ö†Ô∏è During deployment for <a href="http://Render.com">Render.com</a>  you‚Äôll need to add <code>AUTH_SECRET</code> to your environment variables in Settings!</p>
<img src="https://raw.githubusercontent.com/dartmouth-cs52/content-dartmouth-cs52-26w/main/pages/ecsa-frontend-and-backend-authentication/assets/heroku-1767548298128.jpg" alt="">
<div class="heading-block h2-block"><h2>API Server Auth support</h2></div>
<p>Let‚Äôs start adding authentication support to the api server.</p>
<div class="heading-block h3-block"><h3>User Model</h3></div>
<p>To start with, we want to add Users. This means we‚Äôll need a User model.</p>
<p>üöÄ You know models from Lab5 and SA6, oh yes you do. Create a <code>models/user_model.js</code> file. It will be set up identically to your Post model (ie. copy and refactor), but with the following fields:</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span></div><pre><code class="language-javascript">email: { type: String, unique: true, lowercase: true },
password: { type: String }</code></pre></div></div>
<p>For now we won‚Äôt store anything else in the User model, but you may eventually want to add to this.</p>
<p>Make sure you have the config object:</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span></div><pre><code class="language-javascript">{
  toObject: { virtuals: true },
  toJSON: { virtuals: true },
  timestamps: true,
}</code></pre></div></div>
<p>These various settings provide a cleaner output object to JSON with <code>id</code> from <code>_id</code>, and also turns on using timestamps for each record.</p>
<div class="heading-block h3-block"><h3>Salt + Hash</h3></div>
<p>Remember how we planned on saving our passwords?</p>
<img src="https://raw.githubusercontent.com/dartmouth-cs52/content-dartmouth-cs52-26w/main/pages/ecsa-frontend-and-backend-authentication/assets/saving-password-1767548298128.png" alt="">
<p>Now we get to implement that!</p>
<p>üöÄ We‚Äôre going to use the <a href="https://github.com/dcodeIO/bcrypt.js"><code>bcryptjs</code></a> module for this. So you should <code>npm install bcryptjs</code> and import it into your <code>user_model</code> now.</p>
<div class="heading-block h3-block"><h3>Saving Salt+Hash</h3></div>
<p>For saving the password, we‚Äôre going to need a utilize a mongoose <a href="http://mongoosejs.com/docs/middleware.html#pre">pre save hook</a>. This is a bit tricky. We define a function in our <code>user_model</code> that will be called when the User object is saved. It will then take the plain text password and generate a salt and hash the password and save the salt+hash instead.</p>
<p>The syntax for the pre-save hook is:</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span><span class="line-number">11</span></div><pre><code class="language-javascript">yourModelSchema.pre('save', async function beforeyYourModelSave(next) {
  // this is a reference to our model
  // the function runs in some other context so DO NOT bind it
  const model = this;

  //TODO: do stuff here

  // when done run the **next** callback with no arguments
  // call next with an error if you encounter one
  // return next();
});</code></pre></div></div>
<p>For the <a href="https://github.com/dcodeIO/bcrypt.js#usage---async"><code>bcryptjs</code></a> part what we‚Äôll want to do first is generate a salt and then use that salt to hash our password. Take a look at the docs, there‚Äôs a few ways to do it. <code>10</code> (the default) is fine for the number of rounds.</p>
<p>üöÄ construct a method for: <code>userSchema.pre('save', function beforeUserSave(next) {</code>. Don‚Äôt forget that you‚Äôll need to set <code>user</code> to <code>this</code> at the top.</p>
<p>üöÄ Generate a salt as they do in the docs and then hash <code>user.password</code> with the salt. </p>
<p>Tip: in the docs the first argument to hash is the password, in our case you have it in a variable <code>user.password</code> - in case that was confusing documentation.</p>
<p>üöÄ Set the <code>user.password</code> to the hash and <code>return next()</code> which will allow the hook to proceed.</p>
<p>But wait, won‚Äôt this update every single time we save the user? Yes, that might not be ideal if later we want to add in new fields and such!</p>
<p>Luckily, you can add a check to see if the <code>password</code> field is being updated or not at the top:</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span></div><pre><code class="language-javascript">// only hash the password if it has been modified (or is new)
if (!user.isModified('password')) return next();</code></pre></div></div>
<ul><li><p>Great, now we‚Äôve got the first part down, how about comparing.</p></li></ul>
<div class="heading-block h3-block"><h3>Comparing Salt+Hash</h3></div>
<p>We now want to add a method to our model to support comparing passwords. Turns out there is a nice way to <a href="http://mongoosejs.com/docs/guide.html#methods">add methods to a schema</a> in Mongoose. As with anything javascript, everything is just an object, so we can add a property in at anytime.</p>
<p>üöÄ We need to add a method that takes a <code>candidatePassword</code> and returns a boolean. We‚Äôll use the <code>bcrypt.compare</code> functionality to do this. We‚Äôll make this an async function.</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span></div><pre><code class="language-javascript">// note use of named function rather than arrow notation, required here
UserSchema.methods.comparePassword = async function comparePassword(
  candidatePassword,
) {
  const comparison = await bcrypt.compare(candidatePassword, this.password);
  return comparison;
};</code></pre></div></div>
<p>This is slightly adapted for modern js from stackoverflow <a href="https://stackoverflow.com/questions/14588032/mongoose-password-hashing">mongoose-hashing</a>.</p>
<div class="heading-block h3-block"><h3>User Controller</h3></div>
<p>Let‚Äôs add a new User controller!</p>
<p>üöÄ Create a <code>controllers/user_controller.js</code>.</p>
<p>To encode and decode our JWT‚Äôs we‚Äôre going to use the <a href="https://github.com/hokaccha/node-jwt-simple"><code>jwt-simple</code></a>. Go ahead and <code>npm install</code> it and import it: <code>import jwt from 'jwt-simple';</code></p>
<p>üöÄ Also import our new User model and init <code>dotenv</code> same as you did before!</p>
<p>The controller has functions that we call for express routes. We are going to add 2 new routes <code>/signin</code> and <code>/signup</code>, so lets create function headers for those:</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span></div><pre><code class="language-javascript">export const signin = (user) =&gt; {};

//note the lovely destructuring here indicating that we are passing in an object with these 3 keys
export const signup = async ({ email, password }) =&gt; {};</code></pre></div></div>
<p>When we generate a new JWT we need to simply encode a particular bit of json. This json has particular recommended fields which we‚Äôll use. We‚Äôll use <code>sub</code> or subject claim for the <em>user id</em> and <code>iat</code> for the <em>issued at timestamp</em>. This is according to the <a href="https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.2">JWT standard</a>.</p>
<p>üöÄ We‚Äôll just create a helper function for this:</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span></div><pre><code class="language-javascript">// encodes a new token for a user object
function tokenForUser(user) {
  const timestamp = new Date().getTime();
  return jwt.encode({ sub: user.id, iat: timestamp }, process.env.AUTH_SECRET);
}</code></pre></div></div>
<p>What should our two authentication methods do?</p>
<img src="https://raw.githubusercontent.com/dartmouth-cs52/content-dartmouth-cs52-26w/main/pages/ecsa-frontend-and-backend-authentication/assets/token-process-1767548298128.png" alt="">
<p>For <code>signin</code>, once we have verified username/password we can just generate a new token. We‚Äôre going to do the verification with a passport middleware, so our <code>signin</code> function will already be protected ‚Äì all it has to do is return a new token, nice and simple.</p>
<p>For <code>signup</code>, it will be a bit more complicated. We need to create a new User object and save it, but first we need to verify that the user doesn‚Äôt already exist in the system (check their email address).</p>
<p>First, let‚Äôs grab email and password and check them (this is inside the <code>signup</code> function in our <code>user_controller</code>):</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span><span class="line-number">11</span><span class="line-number">12</span><span class="line-number">13</span><span class="line-number">14</span><span class="line-number">15</span><span class="line-number">16</span><span class="line-number">17</span></div><pre><code class="language-javascript">if (!email || !password) {
  throw new Error('You must provide email and password');
}

// See if a user with the given email exists
const existingUser = await User.findOne({ email });
if (existingUser) {
  // If a user with email does exist, return an error
  throw new Error('Email is in use');
}

// üöÄ TODO:
// here you should use the User model to create a new user.
// this is similar to how you created a Post
// and then save and return a token
await user.save();
return tokenForUser(user);</code></pre></div></div>
<p>Ok, now we have our controller and model done. We need one more module. A module that will provide passport authentication services to the rest of the app.</p>
<div class="heading-block h3-block"><h3>Passport Service</h3></div>
<img src="https://raw.githubusercontent.com/dartmouth-cs52/content-dartmouth-cs52-26w/main/pages/ecsa-frontend-and-backend-authentication/assets/passport-logo-1767548298128.png" alt="">
<p>We‚Äôre going to use more npm modules! Yay!</p>
<div class="terminal-block"><div class="terminal-header"><div class="terminal-dots"><span></span><span></span><span></span></div><span class="terminal-title">Terminal</span></div><pre><code class="language-bash">npm install passport passport-local passport-jwt</code></pre></div>
<p>We‚Äôll be using <a href="http://passportjs.org/">Passport.js</a> to provide authentication services. Passport gives us multiple authentication ‚Äústrategies‚Äù. We‚Äôll use <code>passport-local</code> for authenticating with username and password, and <code>passport-jwt</code> for using JWT‚Äôs.</p>
<p>Passport is a middleware in our routes, and it will analyze requests that need to be protected and deal with validating our JWT. It will do this automatically as a middleware on our routes.</p>
<img src="https://raw.githubusercontent.com/dartmouth-cs52/content-dartmouth-cs52-26w/main/pages/ecsa-frontend-and-backend-authentication/assets/passport-strategies-1767548298128.png" alt="">
<p>üöÄ Create a directory and file: <code>services/passport.js</code>.</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span><span class="line-number">11</span><span class="line-number">12</span><span class="line-number">13</span><span class="line-number">14</span><span class="line-number">15</span><span class="line-number">16</span><span class="line-number">17</span><span class="line-number">18</span><span class="line-number">19</span><span class="line-number">20</span><span class="line-number">21</span><span class="line-number">22</span><span class="line-number">23</span><span class="line-number">24</span><span class="line-number">25</span><span class="line-number">26</span><span class="line-number">27</span><span class="line-number">28</span><span class="line-number">29</span><span class="line-number">30</span><span class="line-number">31</span><span class="line-number">32</span><span class="line-number">33</span><span class="line-number">34</span><span class="line-number">35</span><span class="line-number">36</span><span class="line-number">37</span><span class="line-number">38</span><span class="line-number">39</span><span class="line-number">40</span><span class="line-number">41</span><span class="line-number">42</span></div><pre><code class="language-javascript">import passport from 'passport';
import LocalStrategy from 'passport-local';
import { Strategy as JwtStrategy, ExtractJwt } from 'passport-jwt';
import dotenv from 'dotenv';

import User from '../models/user_model';

// loads in .env file if needed
dotenv.config({ silent: true });

// options for local strategy, we'll use email AS the username
// not have separate ones
const localOptions = { usernameField: 'email' };

// options for jwt strategy
// we'll pass in the jwt in an `authorization` header
// so passport can find it there
const jwtOptions = {
  jwtFromRequest: ExtractJwt.fromHeader('authorization'),
  secretOrKey: process.env.AUTH_SECRET,
};
// NOTE: we are not calling this a bearer token (although it technically is), if you see people use Bearer in front of token on the internet you could either ignore it, use it but then you have to parse it out here as well as prepend it on the frontend.

// username/email + password authentication strategy
const localLogin = new LocalStrategy(
  localOptions,
  async (email, password, done) =&gt; {
    // üöÄ TODO: should find user by email and check password
  },
);

const jwtLogin = new JwtStrategy(jwtOptions, async (payload, done) =&gt; {
  // üöÄ TODO: is called with confirmed jwt we just need to confirm that user exits
});

// Tell passport to use this strategy
passport.use(jwtLogin); // for 'jwt'
passport.use(localLogin); // for 'local'

// middleware functions to use in routes
export const requireAuth = passport.authenticate('jwt', { session: false });
export const requireSignin = passport.authenticate('local', { session: false });</code></pre></div></div>
<p>For <code>localLogin</code> we need to run the <code>comparePassword</code> function that we wrote earlier.</p>
<ul><li><p>Here's the <code>localLogin</code> function in the interest of time.</p>

<p>  Read through the above, make sense?</p></li></ul>
<p>‚úçÔ∏è Comment each of the  calls above to explain what case it is and what it is doing. We will grade based on the comments in this case.</p>
<p>For <code>jwtLogin</code>, we are given the payload of the passed in JWT. We need to check the userid and return the found user.</p>
<ul><li><p>Want to give <code>jwtLogin</code> a shot?</p>

<p>  ‚ö†Ô∏è Many mongoose functions return a null object rather than an error ‚Äî hence we have to check that. <code>done</code> is the callback and has the form <code>done(error, value)</code> as is fairly common with some JS libraries.</p></li></ul>
<p>How does this all fit together?</p>
<div class="heading-block h3-block"><h3>Authentication Routes</h3></div>
<p>Now that we have all the required parts, we are ready to tie it all together with Routes!</p>
<p>üöÄ Edit your <code>router.js</code> file:</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span></div><pre><code class="language-javascript">// our imports as usual
import * as UserController from './controllers/user_controller';
import { requireAuth, requireSignin } from './services/passport';</code></pre></div></div>
<p>üöÄ Let‚Äôs add in the <code>/signin</code> route. Note the <code>requireSignin</code>. This is the passport middleware. It makes this route protected by the password+username strategy we defined in our passport.js file. Only once the user is authenticated via that method, will it allow the <code>UserController.signin</code> function to run.</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span></div><pre><code class="language-javascript">router.post('/signin', requireSignin, async (req, res) =&gt; {
  try {
    const token = UserController.signin(req.user);
    res.json({ token, email: req.user.email });
  } catch (error) {
    res.status(422).send({ error: error.toString() });
  }
});</code></pre></div></div>
<p>üöÄ And add in the <code>/signup</code> route.</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span></div><pre><code class="language-javascript">router.post('/signup', async (req, res) =&gt; {
  try {
    const token = await UserController.signup(req.body);
    res.json({ token, email: req.body.email });
  } catch (error) {
    res.status(422).send({ error: error.toString() });
  }
});</code></pre></div></div>
<p>üëÄ See how we are handling the <code>req</code> and <code>res</code> objects in each router function. This will be the pattern that we use, await an async function in the controller then <code>res.json</code> to send the response back to the client.</p>
<p>Note also how we set a status code and then send an error message. Note the 422 is a status code, there are <a href="https://http.cat/">lots of different status codes</a> to choose from, but is usually up to your client to interpret anyway, so choosing is somewhat arbitrary.</p>
<p>Both of these are POSTs, so that implies that we are hoping that the frontend is going to be passing in some data in the request body ‚Äî and that they match the email and password we are expecting.</p>
<p>üöÄ What other routes should be we protect? For now let‚Äôs use <code>requireAuth</code> to protect <code>createPost</code>, <code>updatePost</code>, and <code>deletePost</code>. As easy as: <code>.post('/thepathinyourroute', requireAuth,async (req,res) =&gt; {})</code> That is, you are setting <code>requireAuth</code> as middleware, in the middle between parsing the path, and your function handler.  </p>
<p>Try a <code>curl</code> post to create a new post, you should get an unauthorized error!</p>
<p>Let‚Äôs get a JWT we could use:</p>
<div class="terminal-block"><div class="terminal-header"><div class="terminal-dots"><span></span><span></span><span></span></div><span class="terminal-title">Terminal</span></div><pre><code class="language-bash"># try to signup
curl -X POST -H "Content-Type: application/json" -d '{"email": "test@test.com","password": "password"}' "http://localhost:9090/api/signup"

# then try to signin
curl -X POST -H "Content-Type: application/json" -d '{"email": "test@test.com","password": "password"}' "http://localhost:9090/api/signin"

# try posting!
curl -X POST -H "Content-Type: application/json" -H "authorization: JUST_THE_LONG_TOKEN_STRING" -d '{"title": "test","tags": "sometag","content": "this is a test post"}' "http://localhost:9090/api/posts"</code></pre></div>
<p>Done! You now have an API server that supports authentication. This is fairly rudimentary, but you can expand on this. For instance you can make sure that a user can only update their own posts (just save the userID along with the post).</p>
<p>üÜí Within <code>post_controller.js</code> for any route that is protected by <code>requireAuth</code> you will now have a <code>req.user</code> object. Nice!</p>
<p>üöÄ Might as well just add in recording who the author is with each post now. Edit your <code>post_model.js</code> file and add in this field to your schema: <code>author: { type: Schema.Types.ObjectId, ref: 'User' },</code>. We are saying that the author field is now a reference to a User. We can later get this value automatically filled for us or can use the id to look up the author using <a href="http://mongoosejs.com/docs/populate.html"><code>populate</code></a>.</p>
<p>üöÄ Don‚Äôt forget to update your controller to utilize this new field.</p>
<p>Now when you make new posts, here‚Äôs what your mongo database entry will look like:</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JSON</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span></div><pre><code class="language-json">{ "_id" : ObjectId("57a94e206ec5eae238e359f8"), "author" : ObjectId("57a94813e4c55bb432fc3a4d"), "content" : "this is a test post", "tags" : "words", "title" : "first post MORE TESTING", "__v" : 0 }</code></pre></div></div>
<p>You can also have arrays of objectIds. This might come in handy if you are trying to model other types of relationships.</p>
<div class="heading-block h2-block"><h2>Frontend Authentication</h2></div>
<p>Ok, so now we should update our frontend to support authentication too right? YES!</p>
<div class="heading-block h3-block"><h3>Frontend Auth Summary</h3></div>
<ol start="1"><li>Add in new authentication slice</li><li>Add in <code>/signin</code>, and <code>/signup</code> routes<ul><li>these routes will need associated components</li></ul></li><li>Modify NavBar with links and signout functionality</li><li>Create a new higher order component to allow us to require auth on any frontend components</li></ol>
<div class="heading-block h3-block"><h3>Auth Slice</h3></div>
<p>üöÄ Create a new auth slice in your Zustand store. </p>
<p>We‚Äôll need one state for now: a boolean for <code>authenticated</code> where the default is false, and four actions: <code>loadUser</code> , <code>signinUser</code> , <code>signUpUser</code> , <code>signoutUser</code></p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span><span class="line-number">11</span><span class="line-number">12</span><span class="line-number">13</span><span class="line-number">14</span><span class="line-number">15</span><span class="line-number">16</span><span class="line-number">17</span><span class="line-number">18</span><span class="line-number">19</span><span class="line-number">20</span><span class="line-number">21</span><span class="line-number">22</span><span class="line-number">23</span><span class="line-number">24</span><span class="line-number">25</span><span class="line-number">26</span><span class="line-number">27</span><span class="line-number">28</span><span class="line-number">29</span><span class="line-number">30</span><span class="line-number">31</span><span class="line-number">32</span><span class="line-number">33</span><span class="line-number">34</span><span class="line-number">35</span><span class="line-number">36</span><span class="line-number">37</span><span class="line-number">38</span><span class="line-number">39</span></div><pre><code class="language-javascript">// store/auth-slice.js

import axios from 'axios';

export default function createAuthSlice(set, get) {
  return {
    authenticated: false,
    loadUser: () =&gt; {
      // check for token in local storage
    },
    signinUser: async (fields, navigate) =&gt; {
      // sign in user
      // takes in an object with email and password (minimal user object)
      // does an axios.post on the /signin endpoint and passes in { email, password}
      // on success does:
      //  sets authSlice authenticated state to 'true'
      //  localStorage.setItem('token', response.data.token);
      //  navigates to the home page ('/')
      // on error does:
      //  set error in error slice: get().errorSlice.newError(`Sign In Failed: ${error}`);
    },
    signUpUser: async (fields, navigate) =&gt; {
      // sign up user
      // takes in an object with email and password (minimal user object)
      // does an axios.post on the /signup endpoint (only difference from above)
      // on success does:
      //  sets authSlice authenticated state to 'true'
      //  localStorage.setItem('token', response.data.token);
      // on error does:
      //  set error in error slice: get().errorSlice.newError(`Sign Up Failed: ${error}`);
    },
    signoutUser: async (navigate) =&gt; {
      // sign out user
      // deletes token from localstorage
      // and deauths user
      // sets authSlice authenticated state to 'false'
    },
  };
}</code></pre></div></div>
<p>The most important difference in the above <code>signupUser</code> and <code>signinUser</code> actions is that they take the token that is in the response and put it in <code>localStorage</code>. We‚Äôll be able to access this whenever we load up our site, so we‚Äôll remain logged in without having to re-authenticate every time.</p>
<div class="heading-block h3-block"><h3>Import the new auth slice and specify auth type</h3></div>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span><span class="line-number">11</span><span class="line-number">12</span><span class="line-number">13</span><span class="line-number">14</span><span class="line-number">15</span></div><pre><code class="language-javascript">// store/index.js

// AT THE TOP, WITH YOUR POST SLICE!
import createAuthSlice from './auth-slice';

// INSIDE YOUR USESTORE
const useStore = create(
  devtools(
    immer((...args) =&gt; ({
      authSlice: createAuthSlice(...args), // add in your new auth slice
      // WHATEVER OTHER SLICES/LOGIC YOU HAVE TO HANDLE POST STATE
      authType: 'token', // specify 'token' auth type
    })),
  ),
);</code></pre></div></div>
<p>We import the <code>createAuthSlice</code> function we defined in './auth-slice'.</p>
<p>In the object passed to our existing store creation function, we create a new slice of state named 'authSlice' by calling our new <code>createAuthSlice</code> function.</p>
<p>We also specify an authentication type to use token-based authentication.</p>
<div class="heading-block h3-block"><h3>Authorization Header</h3></div>
<p>We‚Äôll need to add an Authorization Header to some of the existing axios API calls. For each of <code>deletePost</code>, <code>createPost</code>, <code>updatePost</code> you‚Äôll need to modify the axios call to pass in headers. Here‚Äôs what the <code>createPost</code> one will look like:</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span></div><pre><code class="language-javascript">axios.post(`${ROOT_URL}/posts`, post, {
  headers: { authorization: localStorage.getItem('token') },
});</code></pre></div></div>
<p>Note, the headers are in a config object being passed in as a <strong>third argument</strong> to axios.</p>
<div class="heading-block h3-block"><h3>On First Load</h3></div>
<p>üöÄ In your main <code>app.jsx</code> file you should call the <code>loadUser</code> function from your <code>authSlice</code> to check for a token in localStorage if you want it loaded on first start or reload:</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span></div><pre><code class="language-javascript">// include at the top with your imports
import useStore from '../store';

// inside your App component
const loadUser = useStore(({ authSlice }) =&gt; authSlice.loadUser);

// call loadUser in useEffect
useEffect(() =&gt; {
  loadUser();
}, []);</code></pre></div></div>
<p>This will set our state as authenticated if there is a token available that was previously saved. You can debug this in your <em>Application</em> -&gt; <em>Local Storage</em> Chrome inspector tab.</p>
<div class="heading-block h3-block"><h3>Auth state</h3></div>
<p>Your auth slice should have the default state of <code>{ authenticated: false }</code>. Which means the state to access to check if someone is authenticated is simply <code>const authenticated = useStore(({ authSlice }) =&gt; authSlice.authenticated);</code> </p>
<p>You might want to eventually add more things, such as the <code>authorname</code> here later.</p>
<p><em>Why are we just setting a boolean</em>, you ask? Good question. You may want to store something else, like the <code>authorname</code> which is a bit more useful.</p>
<p>The security here is provided by the server, which if you don‚Äôt have a valid token won‚Äôt allow you to do certain operations. The frontend just needs to know whether it has a valid token or not so a boolean will suffice here ‚Äî this is so our user experience can be informed about auth status and show the appropriate pages.  But if a user does get to them, the server will prevent any unauthorized operations anyway.</p>
<div class="heading-block h3-block"><h3>Components</h3></div>
<p>Ok, finally we‚Äôre ready for the <code>SignIn</code> and <code>SignUp</code> components.</p>
<ul><li><strong>SignIn</strong> ‚Äî A component that will use the <code>signinUser</code> function. Simple form with username and password.</li><li><strong>SignUp</strong> ‚Äî A component that will use the <code>signupUser</code> function. Simple form with whatever fields you want a user to have.</li></ul>
<p>üöÄ Create these components. You can base them off of your New Post component pretty easily. Feel free to create one single component for this with different buttons triggering the signup / signin if you prefer that UX.</p>
<p>üöÄ Add Routes to these components inside <code>&lt;Routes&gt;&lt;/Routes&gt;</code> in your main <code>app.jsx</code> file.</p>
<div class="heading-block h3-block"><h3>NavBar</h3></div>
<p>For SignOut simply make grant our NavBar component access to the <code>signoutUser</code> function. That function can do a <code>navigate</code> to ‚Äò/‚Äô on signout. You can just have a signout button that triggers this function. Then use the <code>authSlice.authenticated</code> to only show the signout button if a user is logged in, and signup/signout otherwise.</p>
<p>Additionally add Links to <code>/signin</code> and <code>/signup</code>.</p>
<div class="heading-block h3-block"><h3>Authorized Component</h3></div>
<p>One last thing. Right now an unauthenticated user can access the ‚ÄúAdd a post‚Äù functionality. They will get an error (if you implemented an error state+function+component) or just a submit button that doesn‚Äôt work. Let‚Äôs make that page <strong>protected</strong> so that if the user isn‚Äôt authenticated they will be prompted to log in. Rather than adding checks into each of our components, we are going to create a <em>higher order</em> component that wraps Route! How might you go about doing this?</p>
<p>What we can do is create a new component that wraps a Route component and some logic inside it.</p>
<p>üöÄ Create a new component <code>requireAuth.js</code>.</p>
<p>Here‚Äôs it is in toto:</p>
<div class="code-block"><div class="code-header"><span class="code-lang">JavaScript</span></div><div class="code-body"><div class="line-numbers"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span><span class="line-number">11</span><span class="line-number">12</span><span class="line-number">13</span><span class="line-number">14</span><span class="line-number">15</span><span class="line-number">16</span><span class="line-number">17</span></div><pre><code class="language-javascript">import React from 'react';
import { Navigate } from 'react-router-dom';

import useStore from '../store';

// Router Wrapper
function RequireAuth({ children }) {
  const authenticated = useStore(({ authSlice }) =&gt; authSlice.authenticated);

  if (!authenticated) {
    return &lt;Navigate to="/signin" /&gt;;
  } else {
    return children;
  }
}

export default RequireAuth;</code></pre></div></div>
<p>Note how it is a nice simple function component that simply checks if we are authenticated and if not navigates to sign-in.</p>
<p>üöÄ&nbsp;Now in your <code>&lt;Routes&gt;</code> in <code>app.jsx</code> you can import <code>RequireAuth</code> and protect the <code>New</code> path like so: <code>&lt;Route path="/posts/new" element={ &lt;RequireAuth&gt; &lt;New/&gt; &lt;/RequireAuth&gt; } /&gt;</code></p>
<div class="heading-block h2-block"><h2>Extend the User Model with Author</h2></div>
<p>üöÄ Extend the User Model to store the author‚Äôs name in addition to email, and add in support for that everywhere: express routes, user_model, user_controller, post_model, post_controller, Zustand state, function, and post components.</p>
<p>üöÄ Display the Author Name along with every post. You are welcome to either duplicate the name and store it directly as a field in the Post model, or look it up by reference. Note: <code>name</code> is a reserved word in JS and can cause problems if you reassign object.name, so call your field something other than name (e.g. <code>authorname</code> or <code>username</code>)</p>
<p>üçπThe best time/place to have access to the User object is actually right when you create the post on the api side. Since that route is an authenticated route wrapped in our <code>requireAuth</code> middleware, passport adds a <code>user</code> object to the request for you!  In your createPost method in your post controller you would have access to: <code>req.user</code>. If the user object has say an <code>authorname</code> field, then that would be available there for you to then save along with the post.</p>
<p>There are 2 ways to associate the user with the post. You can save a <code>ref</code> to the whole user object (which you started to set up when you added author as an ObjectID type field). If you do that, then later when you retrieve the user you need to use <a href="http://mongoosejs.com/docs/populate.html"><code>populate</code></a> to fill in the object. Or you could add a <code>authorname</code> field to post and assign that. Using a reference and populating on retrieval is the better way, you can even select which field specifically to populate so you aren‚Äôt sending the whole user object if you don‚Äôt want to.</p>
<div class="heading-block h2-block"><h2>Test and Submit</h2></div>
<p>Test it all out and make sure all the parts still work!  The cypress tests have a suite for testing our authentication api routes so use those to help.</p>
<p>Commit and push both both your Lab5 and Lab4 withAuth branches.  Deploy everything - in render choose your <code>withAuth</code> branches for new sites so you have 2 new URLS: <code>Lab4+auth</code>, and <code>Lab5+auth</code> . At this point you don‚Äôt need any help with that.</p>
<div class="heading-block h2-block"><h2>To Turn In</h2></div>
<ol start="1"><li>make a comment on the auth ec issue and submit links to the github branches as well as the deployed versions of each of your frontend and backend.<ol start="1"><li>include a couple sentence description about what you did</li></ol></li><li>your app should:<ul><li>have users sign-in, sign-up, sign-out</li><li>not allow people to access /posts/new when not logged in</li><li>have a user model that stores authorname, salt+hashed password, and name</li><li>have a new Zustand auth slice to handle all auth state and functions</li></ul></li></ol>
<div class="heading-block h2-block"><h2>Extra Credit on Extra Credit!</h2></div>
<p><em>always mention your extra credit in the README.md file</em></p>
<ul><li>so you now have users, what can you do with users? so many things!</li><li>if you didn‚Äôt add error message handling before you should do it now (error state in store, error reducer, error action, error component)</li><li>add more pages and content to your app, how about a profile page for each user (add in /user frontend route and api endpoints)</li><li>extend the permissions system so that users can only edit their own posts</li><li>add in commenting system, authenticated users can comment on posts</li><li>suggest something else, this is your time to make this your own!</li></ul>
</body>
</html>